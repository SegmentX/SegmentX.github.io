{"posts":[{"title":"MCU GPIO 输入输出模式","content":"MCU的GPIO可配置为输入（四种模式），输出（四种模式），基于STM32，对这八种模式做简要总结 STM32GPIO端口结构图： 对于标准施密特触发器，当输入电压高于正向阈值电压，输出为低；当输入电压低于负向阈值电压，输出为高；当输入在正负向阈值电压之间，输出不改变，也就是说输出由高电准位翻转为低电准位，或是由低电准位翻转为高电准位时所对应的阈值电压是不同的。只有当输入电压发生足够的变化时，输出才会变化，因此将这种元件命名为触发器。这种双阈值动作被称为迟滞现象，表明施密特触发器有记忆性。从本质上来说，施密特触发器是一种双稳态多谐振荡器。 输入模式 输入浮空（GPIO_Mode_IN_FLOATING） 输入上拉(GPIO_Mode_IPU) 输入下拉(GPIO_Mode_IPD) 模拟输入(GPIO_Mode_AIN) 输出模式 开漏输出(GPIO_Mode_Out_OD) 开漏复用功能(GPIO_Mode_AF_OD) 推挽式输出(GPIO_Mode_Out_PP) 推挽式复用功能(GPIO_Mode_AF_PP) 模拟输入：读取外界电压 模拟输入是指传统方式的输入，数字输入是输入PCM数字信号，即0,1的二进制数字信号，通过数模转换，转换成模拟信号，经前级放大进入功率放大器，功率放大器还是模拟的 不理解 浮空输入：读取外界电平（RX） 浮空就是逻辑器件与引脚即不接高电平，也不接低电平。由于逻辑器件的内部结构，当它输入引脚悬空时，相当于该引脚接了高电平。一般实际运用时，引脚不建议悬空，易受干扰。通俗讲就是浮空就是浮在空中，就相当于此端口在默认情况下什么都不接，呈高阻态，这种设置在数据传输时用的比较多。浮空最大的特点就是电压的不确定性，它可能是0V，页可能是VCC，还可能是介于两者之间的某个值（最有可能） 浮空一般用来做ADC输入用，这样可以减少上下拉电阻对结果的影响？？？？ 下拉输入： 就是把电压拉低，拉到GND。检测输入高电平。 上拉输入： 上拉就是把点位拉高，比如拉到Vcc。上拉就是将不确定的信号通过一个电 阻嵌位在高电平。检测输入低电平 开漏输出：（输出强低电平） 输出端相当于三极管的集电极，要得到高电平状态需要上拉电阻才行，输出高电平时由外部上拉电阻决定 推挽输出：（可输出强高低电平） 可以输出高，低电平，连接数字器件;推挽结构一般是指两个三级管分别受到互补信号的控制，总是在一个三极管导通的时候另一个截止。高低电平由IC的电源低定。 复用开漏输出&amp;复用推挽输出 输出电平来源不一样，由外设驱动 该部分内容可参考https://blog.csdn.net/baidu_37366055/article/details/80060962 http://www.openedv.com/posts/list/21980.htm GPIO的寄存器 每个GPIO端口都有 两个32位配置寄存器（GPIOx_CRL , GPIOx_CRH） 两个32位数据寄存器（GPIOx_IDR 和 GPIOx_ODR） 一个32位置位/复位寄存器（GPIOx_BSRR） 一个16位复位寄存器（GPIOx_BRR） 一个32位锁定寄存器（GPIOx_LCKR） 每个I/O端口位可以自由编程，然而I/O端口寄存器必须按32位字被访问(不允许半字或字节访问) 每组IO口含下面7个寄存器。也就是7个寄存器，一共可以控制一组GPIO的16个IO口。 GPIOx_CRL :端口配置低寄存器 GPIOx_CRH:端口配置高寄存器 GPIOx_IDR:端口输入寄存器 GPIOx_ODR:端口输出寄存器 GPIOx_BSRR:端口位设置/清除寄存器，可直接设置IO输出高低电平 GPIOx_BRR :端口位清除寄存器，可直接设置IO输出低电平 GPIOx_LCKR:端口配置锁存寄存器 ","link":"https://SegmentX.github.io/post/mcu-gpio-shu-ru-shu-chu-mo-shi/"},{"title":"Hello World","content":"hello，这是第一篇文章，本博客GitHup和Gridea搭建，写写工作中遇到的一些问题，技术积累及自己对IT行业的一些看法及想法，方向主要为单片机，自动驾驶，及手机行业，文采很扯，你忍一下🗣🗣🗣 ","link":"https://SegmentX.github.io/post/hello-world/"}]}